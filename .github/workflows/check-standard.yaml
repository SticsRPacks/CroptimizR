# Workflow derived from https://github.com/r-lib/actions/tree/v2/examples
# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help
on:
  push:
    branches: [main, master]
  pull_request:

name: R-CMD-check

jobs:
  R-CMD-check:
    runs-on: ${{ matrix.config.os }}

    name: ${{ matrix.config.os }} (${{ matrix.config.r }})

    strategy:
      fail-fast: false
      matrix:
        config:
          #- { os: macos-latest, r: "release" }
          - { os: windows-latest, r: "release" }
          - { os: windows-latest, r: "4.2.0" }
          - {
              os: ubuntu-latest,
              r: "release",
              rspm: "https://packagemanager.rstudio.com/cran/__linux__/focal/latest",
            }

    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      R_KEEP_PKG_SOURCE: yes

    steps:
      - uses: actions/checkout@v6
      - uses: r-hub/actions/setup-r-sysreqs@v1 # Install and setup R system dependencies on macOS.
        with:
          type: full

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ matrix.config.r }}
          http-user-agent: ${{ matrix.config.http-user-agent }}
          use-public-rspm: true

      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::rcmdcheck
          needs: check

      - name: Install custom R dependencies
        run: |
          # Temporarily forcing ggplot2 to v3.5.2 on main branch (see https://github.com/SticsRPacks/CroPlotR/issues/84)
          remotes::install_version("ggplot2", version = "3.5.2", upgrade = "never")
        shell: Rscript {0}

      - uses: r-lib/actions/check-r-package@v2
        with:
          upload-snapshots: true
          build_args: 'c("--no-manual","--compact-vignettes=gs+qpdf")'

  # Trigger CI using SticsRTest
  trigger-SticsRTest:
    name: Trigger SticsRTest check
    # Triggering for every branch when checks succeeded
    needs: R-CMD-check
    if: github.event_name == 'push' && needs.R-CMD-check.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.TRIGGER_PAT }}
          repository: SticsRPacks/SticsRTests
          event-type: R-CMD-check
          client-payload: '{"ref": "${{ github.ref }}", "sha": "${{ github.sha }}", "repo": "${{ github.event.repository.name }}"}'
      - name: Wait for SticsRTests workflow to complete (block-and-fail)
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.TRIGGER_PAT }}
          script: |
            const owner = 'SticsRPacks';
            const repo = 'SticsRTests';
            // The dispatched sha from the source workflow
            const headSha = process.env.GITHUB_SHA;
            const maxWaitMs = 30 * 60 * 1000; // 30 minutes
            const pollIntervalMs = 15 * 1000; // 15s
            const start = Date.now();

            function sleep(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            while (Date.now() - start < maxWaitMs) {
              const res = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 100 });
              const runs = (res.data.workflow_runs || []).filter(r => r.event === 'repository_dispatch');

              // Prefer matching by head_sha, fallback to the most recent repository_dispatch run
              let run = runs.find(r => r.head_sha === headSha) || runs.sort((a,b) => new Date(b.created_at) - new Date(a.created_at))[0];

              if (!run) {
                console.log('No repository_dispatch run found yet, sleeping...');
                await sleep(pollIntervalMs);
                continue;
              }

              console.log(`Found run id=${run.id} status=${run.status} conclusion=${run.conclusion} created_at=${run.created_at}`);

              if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  console.log('SticsRTests workflow succeeded.');
                  return { runId: run.id, conclusion: run.conclusion };
                } else {
                  throw new Error(`SticsRTests workflow completed with conclusion: ${run.conclusion}`);
                }
              }

              // not completed yet
              await sleep(pollIntervalMs);
            }

            throw new Error('Timed out waiting for SticsRTests workflow to start/complete (timeout reached).');
