---
title: "Guidelines for implementing a crop model R wrapper for CroptimizR"
author: 
- name: "Samuel Buis"
  affiliation: "INRAE - EMMAH"
- name: "Patrice Lecharpentier"
  affiliation: "INRAE - Agroclim"
date: "`r Sys.Date()`"
output:
   html_document:
     toc: true
     toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Introduction

R wrappers are necessary to couple crop models with CroptimizR. An R wrapper is basically an R function able to run model simulations for prescribed values of some of its input parameters and to return the values of its simulated outputs. 
It must have specific arguments, returned values and behavior, as detailed in the following. 

## How to write a basic version of a model wrapper for CroptimizR

We will detail here what is mandatory in terms of interface of the wrapper and expected behavior. Optional issues for more advanced users are detailed in the next section

### Model wrapper interface

Here's a header for a basic version of a model wrapper:

```{r eval=FALSE}
#' @title MyModel wrapper for CroptimizR
#'
#' @description This function run my crop model and may force it with the values 
#' of the parameters defined in the param_values argument. It returns the values 
#' of the (possibly selected) simulated outputs.
#'
#' @param model_options List containing any information needed to run the model. 
#'
#' @param param_values Either a named vector or a named 3D array.
#' Use a named vector that contains the values and names of the parameters to force whatever
#' the simulated situations.
#' If one wants to force the model with different values of parameters for the
#' simulated situations or to simulate the situations several times but with different
#' values of the parameters, use a 3D array containing the value(s) and names of the
#' parameters to force for each situation to simulate. This array contains the different
#' parameters values (first dimension) for the different parameters (second dimension)
#' and for the different situations (third dimension).
#'
#' @param sit_var_dates_mask (optional)
#' Has no effect in this version of the wrapper
#'
#' @return A list containing simulated values (`sim_list`: a vector of list (one
#' element per values of parameters) containing data.frames of simulated output values) and an
#' error code (`error`) indicating if at least one simulation ended with an error.

model_wrapper <- function( model_options, param_values=NULL, 
                           site_var_dates_mask=NULL) {
  ...
  
}

```

Each argument detailed here is mandatory for any CroptimizR model wrapper. You can use this header to develop yours.
Note that site_var_dates_mask will have no effect in this basic version of the wrapper.

The shape of the param_values argument is imposed by CroptimizR. This is not the case of the model_options argument (except the fact that is must be a list): its content must be defined by the developper of the model wrapper. Put in this list what you need to run the model (e.g. path to the executable, path the directory containing model input files for the simulated situations, ...). 


### Minimum required functionalities

* Run the model on a specified set of situations
A situation corresponds to a simulation (for example a specific treatment on a given soil for a given period).
The names of the situations are the names of dimension 3 of param_values. They will be given by the end user when calling CroptimizR functions. To retrieve them, use `dimnames(param_values)[[3]]`. 

* Force the model with specified values of its parameters
The values of the parameters are specified in the param_values array. The names of the parameters are the names of dimension 2 of param_values.
To retrieve them use `dimnames(param_values)[[2]]`.
Different values can be defined for different situations and multiple values can be defined for a given situation.
param_values can for example contain:

```{r}
param_values <- array( c(0.001, 0.002, 50, 50,
                         0.001, 0.002, 60, 60,
                         0.001, 0.002, 70, 70),
                       dim=c(2,2,3),
                       dimnames=list(NULL,c("param1", "param2"),c("situation1", "situation2", "situation3")))

param_values
```

In this case for example, values c(0.001, 50) and c(0.002, 50) of parameters param1 and param2 must be given in input of the model for situation1, c(0.001, 60) and c(0.002, 60) for situation2 and c(0.001, 70) and c(0.002, 70) for situation3.

* Retrieve the simulated results for all simulated variables 
The results must be stored in `result$sim_list` variable. `sim_list` is a vector of list, of size the size of the first dimension of param_values.
You can initialize it like this: `result$sim_list <- vector("list",dim(param_values)[1])`.
Each element of the list should contains a list of data.frame, one per situation, with the results obtained for all simulated variables and dates.
The data.frame must have one column called Date containing the simulations dates in POSIXct format (see R function `base::as.POSIXct`). The other columns contains the values of the simulated variables and their names must be put as column names.

For example, given the param_values array defined above, sim_list should look like:

```{r eval=FALSE}

$sim_list
$sim_list[[1]]
$sim_list[[1]]$situation1
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1994-10-17 00:00:00  0      2.53    4.80
#> 2 1994-10-18 00:00:00  0      2.31    4.66
#> 3 1994-10-19 00:00:00  0      4.55    4.44
#

$sim_list[[1]]$situation2
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1995-10-17 00:00:00  0      2.60    4.80
#> 2 1995-10-18 00:00:00  0      3.42    4.70
#> 3 1995-10-19 00:00:00  0      5.25    4.45
#

$sim_list[[1]]$situation3
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1996-10-17 00:00:00  0      2.41    4.81
#> 2 1996-10-18 00:00:00  0      3.03    4.71
#> 3 1996-10-19 00:00:00  0      5.10    4.47
#


$sim_list[[2]]
$sim_list[[2]]$situation1
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1994-10-17 00:00:00  0.1    2.55    4.80
#> 2 1994-10-18 00:00:00  0.1    2.32    4.66
#> 3 1994-10-19 00:00:00  0.1    4.57    4.44
#

$sim_list[[2]]$situation2
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1995-10-17 00:00:00  0.1    2.62    4.80
#> 2 1995-10-18 00:00:00  0.1    3.40    4.70
#> 3 1995-10-19 00:00:00  0.1    5.26    4.45
#

$sim_list[[2]]$situation3
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1996-10-17 00:00:00  0.1    2.42    4.81
#> 2 1996-10-18 00:00:00  0.1    3.04    4.71
#> 3 1996-10-19 00:00:00  0.1    5.11    4.47
#
   
```


* Return an error code if any simulation failed
If any simulation failed for any reason, the variable `result$error` must contain `TRUE` and `FALSE` otherwise.


### Implementation

A typical pseudo-code implementation of the wrapper function is thus:

```{r eval=FALSE}

model_wrapper <- function( model_options, param_values=NULL, 
                           site_var_dates_mask=NULL) {
  
  # Initializations
  nb_paramValues <- dim(param_values)[1]
  param_names <- dimnames(param_values)[[2]]
  situation_names <- dimnames(param_values)[[3]]
  result$sim_list <- vector("list",dim(param_values)[1])
  results$error=FALSE
  
  for (i in 1:nb_paramValues) {
    
    for (situation in situation_names) {
      
      # overwrite model input parameters of names contained in param_names with values retrieved in param_values[i,,situation]
      
      # run the model
      
      # read the results and store the data.frame in result$sim_list[[i]][[situation]]
      
      if (any error returned by the model or detected in its results) {
        results$error=TRUE
      }
      
    }
    
  }
  
  return(results)
  
}

   
```


## Optional issues

* Check wrapper arguments:

If possible implement any check you can concerning what is given to the wrapper. Print a message using the `warning` function and return TRUE in `results$error` if a problem is detected.
It may be an unknown model input parameter (`dimnames(param_values)[[2]]`), situation name (`dimnames(param_values)[[3]]`), variable name (in `site_var_dates_mask`) or an incorrect model option (field of `model_option`) such as an incorrect model path for example.

* Perform parallel calculations:

If possible with your model (pay attention to concurrency access to model input and output files), managing parallel simulations of the different situations (dimension 3 of param_values) or for the different parameters values (dimension 1 of param_values) may drastically reduce the execution time.

The doParallel package can be used for that. There are specificities when coding a parallel loop: in particular, a list pre allocated outside of the loop is not shared between cores so return statements must be used inside. Here is an example for illustrating this issue:


```{r warning=FALSE}
# Code of an example of foreach loop algo
library("doParallel")

test_parallel <- function(cores_nb = 1,
                          pa = FALSE,
                          max_it = 5) {
# pa: flag to switch from case with pre-allocated list to case with returned statement
  
  
  # Launching the cluster
  cl <- makeCluster(cores_nb)
  registerDoParallel(cl)
  
  # List preallocation
  out_pa <- vector(mode = "list", max_it)
  
  # Parallel loop
  out <- foreach(i = 1:max_it) %dopar% {
    if (pa) {  
      out_pa[[i]] <- i  # store results in a pre-allocted list
    } else {
      return(i)         # return the results
    }
  }
  
  # Stopping the cluster
  stopCluster(cl)
  
  if (pa) {
    return(out_pa)
  } else {
    return(out)
  }
  
  
}

cores_nb=2

# Case with returned statement
out <- test_parallel(cores_nb)

# Case with pre-allocated list
out_pa <- test_parallel(cores_nb, TRUE)

out

out_pa

```



* Outputs selection

The argument `sit_var_dates_mask` may be used to return a selection of variables and dates per simulated situations.
This may save execution time for some models (for example if model results are read in a databasis with specific request per variable).

`sit_var_dates_mask` is a list of data.frame similar to `result$sim_list[[i]]`. It indicates the list of variables and dates for each situation for which results must be returned: if `sit_var_dates_mask$situation1[j,"var1"]` does not contain NA, then the simulated value of variable "var1" at date `sit_var_dates_mask$situation1[j,"Date"]` must be returned in `results$sim_list[[i]][["situation1"]]`.


## Examples

Examples of crop model wrappers for CroptimizR can be found in the SticsOnR package (https://github.com/SticsRPacks/SticsOnR/blob/master/R/stics_wrapper.R) for the Stics model and in the ApsimOnR package (https://github.com/hol430/ApsimOnR/blob/master/R/apsimx_wrapper.R) for ApsimX model.

Note however that the Stics wrapper is a bit complex since it aims not only to be used in CroptimizR but also directly by the user to launch Stics simulations from R. Different datatypes are thus possible for `param_values` and `sit_var_dates_mask` to that end.

