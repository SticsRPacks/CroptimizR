---
title: "Guidelines for implementing a crop model R wrapper for CroptimizR"
author: 
- name: "Samuel Buis"
  affiliation: "INRAE - EMMAH"
- name: "Patrice Lecharpentier"
  affiliation: "INRAE - Agroclim"
date: "`r Sys.Date()`"
output:
   html_document:
     toc: true
     toc_float: true
vignette: >
  %\VignetteIndexEntry{Designing a model wrapper}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Introduction

R wrappers are necessary to couple crop models with CroptimizR. An R wrapper is basically an R function able to run model simulations for prescribed values of some of its input parameters and to return the values of its simulated outputs. 
It must have specific arguments, returned values and behavior, as detailed in the following. 

## How to write a basic version of a model wrapper for CroptimizR

We will detail here what is mandatory in terms of interface of the wrapper and expected behavior. Optional issues for more advanced users are detailed in the next section

### Model wrapper interface

Here's a header for a basic version of a model wrapper:

```{r eval=FALSE}
#' @title MyModel wrapper for CroptimizR
#'
#' @description This function runs my crop model and force it with the values 
#' of the parameters defined in the param_values argument. It returns 
#' the values of the simulated outputs.
#'
#' @param model_options List containing any information needed to run the model. 
#'
#' @param param_values Named 3D array that contains the value(s) and names of the
#' parameters to force for each situation to simulate. This array contains the different
#' parameters values (first dimension) for the different parameters (second dimension)
#' and for the different situations (third dimension).
#'
#' @return A list containing simulated values (`sim_list`: a vector of list (one
#' element per values of parameters) containing data.frames of simulated output values 
#' for each simulated situation) and an error code (`error`) indicating if at least 
#' one simulation ended with an error.

model_wrapper <- function( model_options, param_values, ...) {

}

```

Each argument detailed here is mandatory for any CroptimizR model wrapper. You can use this header to develop yours.
Be careful, "..." is mandatory at the end of the argument list since CroptimizR may give additional arguments for more advanced wrappers.

The shape of the param_values argument is imposed by CroptimizR. This is not the case of the model_options argument (except the fact that is must be a list): its content must be defined by the developper of the model wrapper. Put in this list what you need to run the model (e.g. path to the executable, path the directory containing model input files for the simulated situations, ...). 


### Minimum required functionalities

* Run the model on a specified set of situations
A situation corresponds to a simulation (for example a specific treatment on a given soil for a given period).
The names of the situations are the names of dimension 3 of param_values. They will be given by the end user when calling CroptimizR functions. To retrieve them, use `dimnames(param_values)[[3]]`. 

To run your model from R, several technical solutions are possible depending on the language it is implemented with. 
A simple solution (although not the most computationally efficient) is to run its executable using the R function `system2`.
Otherwise, different languages can be directly interfaced in R: for example Python, using the R package `reticulate`, C and C++ (see e.g.  (https://www.r-bloggers.com/three-ways-to-call-cc-from-r/)), fortran (see e.g. (https://www.r-bloggers.com/fortran-and-r-speed-things-up/))...


* Force the model with specified values of its parameters
The values of the parameters are specified in the param_values array. The names of the parameters are the names of dimension 2 of param_values.
To retrieve them use `dimnames(param_values)[[2]]`.
Different values can be defined for different situations and multiple values can be defined for a given situation.
param_values can for example contain:

```{r}
param_values <- array( c(0.001, 0.002, 50, 50,
                         0.001, 0.002, 60, 60,
                         0.001, 0.002, 70, 70),
                       dim=c(2,2,3),
                       dimnames=list(NULL,c("param1", "param2"),c("situation1", "situation2", "situation3")))

param_values
```

In this case for example, values c(0.001, 50) and c(0.002, 50) of parameters param1 and param2 must be given in input of the model for situation1, c(0.001, 60) and c(0.002, 60) for situation2 and c(0.001, 70) and c(0.002, 70) for situation3.

* Retrieve the simulated results for all simulated variables 
The results must be stored in `result$sim_list` variable. `sim_list` is a vector of list, of size the size of the first dimension of param_values.
You can initialize it like this: `result$sim_list <- vector("list",dim(param_values)[1])`.
Each element of the list should contains a list of data.frame, one per situation, with the results obtained for all simulated variables and dates.
The data.frame must have one column called `Date` containing the simulations dates in Date or POSIXct format (see R function`base::as.Date` or `base::as.POSIXct`). The other columns contains the values of the simulated variables and their names must be put as column names.

For example, given the param_values array defined above, sim_list should look like:

```{r eval=FALSE}

$sim_list
$sim_list[[1]]
$sim_list[[1]]$situation1
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1994-10-17 00:00:00  0      2.53    4.80
#> 2 1994-10-18 00:00:00  0      2.31    4.66
#> 3 1994-10-19 00:00:00  0      4.55    4.44
#

$sim_list[[1]]$situation2
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1995-10-17 00:00:00  0      2.60    4.80
#> 2 1995-10-18 00:00:00  0      3.42    4.70
#> 3 1995-10-19 00:00:00  0      5.25    4.45
#

$sim_list[[1]]$situation3
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1996-10-17 00:00:00  0      2.41    4.81
#> 2 1996-10-18 00:00:00  0      3.03    4.71
#> 3 1996-10-19 00:00:00  0      5.10    4.47
#


$sim_list[[2]]
$sim_list[[2]]$situation1
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1994-10-17 00:00:00  0.1    2.55    4.80
#> 2 1994-10-18 00:00:00  0.1    2.32    4.66
#> 3 1994-10-19 00:00:00  0.1    4.57    4.44
#

$sim_list[[2]]$situation2
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1995-10-17 00:00:00  0.1    2.62    4.80
#> 2 1995-10-18 00:00:00  0.1    3.40    4.70
#> 3 1995-10-19 00:00:00  0.1    5.26    4.45
#

$sim_list[[2]]$situation3
# A tibble: *** x ***
   Date                  var1    var2    var3  ...
#>   <dttm>              <dbl>   <dbl>   <dbl> 
#> 1 1996-10-17 00:00:00  0.1    2.42    4.81
#> 2 1996-10-18 00:00:00  0.1    3.04    4.71
#> 3 1996-10-19 00:00:00  0.1    5.11    4.47
#
   
```


* Return an error code if any simulation failed
If any simulation failed for any reason, use the R function `warning` to print any useful information about the error and set the variable `result$error` to `TRUE` (and to `FALSE` otherwise).


### Implementation

A typical pseudo-code implementation of the wrapper function is thus:

```{r eval=FALSE}

model_wrapper <- function( model_options, param_values, ...) {
  
  # Initializations
  nb_paramValues <- dim(param_values)[1]
  param_names <- dimnames(param_values)[[2]]
  situation_names <- dimnames(param_values)[[3]]
  result$sim_list <- vector("list",dim(param_values)[1])
  results$error=FALSE
  
  for (i in 1:nb_paramValues) {
    
    for (situation in situation_names) {
      
      # overwrite model input parameters of names contained in param_names with values retrieved in param_values[i,,situation]
      
      # run the model for the given situation 
      
      # read the results and store the data.frame in result$sim_list[[i]][[situation]]
      
      if (any_error_returned_by_the model_or_detected_in_its_results) {
        warning("any_useful_information_to_describe_the_error")
        results$error=TRUE
      }
      
    }
    
  }
  
  return(results)
  
}

   
```


### Test your wrapper

You can implement the following tests to check your wrapper is working as expected:

* check the results returned by the wrapper (`sim_max$sim_list`) are identical to what is given by your model when used in a standard way (i.e. not through the wrapper)

* run the wrapper with different values of parameters and check it gives different simulated values. You can do that using the following :

```{r eval=FALSE}

param_names=    # set the name of one or several model input parameters in a vector
param_lb=       # set the lower bounds of these parameters in a vector (no Inf or -Inf ...)
param_ub=       # set the upper bounds of these parameters in a vector (no Inf or -Inf ...)
var_name=       # give the name of an output variable sensitive to this (or these) parameter(s)
situation_name= # give the name of the situation to simulate 
model_options=  # give the model options
wrapper=        # give the name of tyour wrapper

  
param_values_min <- array( param_lb,
                       dim=c(1,length(param_lb),1),
                       dimnames=list(NULL,param_names,situation_name))

param_values_max <- array( param_ub,
                       dim=c(1,length(param_ub),1),
                       dimnames=list(NULL,param_names,situation_name))

sim_max       <- wrapper(param_values = param_values_min, model_options = model_options)

sim_min       <- wrapper(param_values = param_values_max, model_options = model_options)

print(paste("Sum of differences, variable",var_name,", situation",situation_name," = ",
             sum(abs(sim_max$sim_list[[1]][[situation_name]][,var_name]-sim_min$sim_list[[1]][[situation_name]][,var_name]),na.rm=TRUE)))
# Should give a value different from 0.
   
```

* Try to play with estim_param on your wrapper for a simple case (e.g. a single situation, variable and parameter, see e.g. (https://sticsrpacks.github.io/CroptimizR/articles/Parameter_estimation_simple_case.html)).



## Optional issues

* Check wrapper arguments:

If possible implement any check you can concerning what is given to the wrapper. Print a message using the `warning` function and return TRUE in `results$error` if a problem is detected.
It may be an unknown model input parameter (`dimnames(param_values)[[2]]`), situation name (`dimnames(param_values)[[3]]`), variable name (in `sit_var_dates_mask`) or an incorrect model option (field of `model_option`) such as an incorrect model path for example.

* Perform parallel calculations:

If possible with your model (pay attention to concurrency access to model input and output files), managing parallel simulations of the different situations (dimension 3 of param_values) or for the different parameters values (dimension 1 of param_values) may drastically reduce the execution time.

The doParallel package can be used for that. There are specificities when coding a parallel loop: in particular, a list pre allocated outside of the loop is not shared between cores so return statements must be used inside. Here is an example for illustrating this issue:


```{r warning=FALSE}
# Code of an example of foreach loop algo
library("doParallel")

test_parallel <- function(cores_nb = 1,
                          pa = FALSE,
                          max_it = 5) {
# pa: flag to switch from case with pre-allocated list to case with returned statement
  
  
  # Launching the cluster
  cl <- makeCluster(cores_nb)
  registerDoParallel(cl)
  
  # List preallocation
  out_pa <- vector(mode = "list", max_it)
  
  # Parallel loop
  out <- foreach(i = 1:max_it) %dopar% {
    if (pa) {  
      out_pa[[i]] <- i  # store results in a pre-allocted list
    } else {
      return(i)         # return the results
    }
  }
  
  # Stopping the cluster
  stopCluster(cl)
  
  if (pa) {
    return(out_pa)
  } else {
    return(out)
  }
  
  
}

cores_nb=2

# Case with returned statement
out <- test_parallel(cores_nb)

# Case with pre-allocated list
out_pa <- test_parallel(cores_nb, TRUE)

out

out_pa

```


* Outputs selection

An additional argument called `sit_var_dates_mask` can be defined in the wrapper. It can be used to return a selection of variables and dates per simulated situations.
This may save execution time for some models (for example if model results are read in a databasis with specific request per variable).

`sit_var_dates_mask` is a list of data.frame similar to `result$sim_list[[i]]`. It indicates the list of variables and dates for each situation for which results must be returned: if `sit_var_dates_mask$situation1[j,"var1"]` does not contain NA, then the simulated value of variable "var1" at date `sit_var_dates_mask$situation1[j,"Date"]` must be returned in `results$sim_list[[i]][["situation1"]]`.


## Examples

Examples of crop model wrappers for CroptimizR can be found in the SticsOnR package (https://github.com/SticsRPacks/SticsOnR/blob/master/R/stics_wrapper.R) for the Stics model and in the ApsimOnR package (https://github.com/hol430/ApsimOnR/blob/master/R/apsimx_wrapper.R) for ApsimX model.

Note however that the Stics wrapper is a bit complex since it aims not only to be used in CroptimizR but also directly by the user to launch Stics simulations from R. Different datatypes are thus possible for `param_values` and `sit_var_dates_mask` to that end.

